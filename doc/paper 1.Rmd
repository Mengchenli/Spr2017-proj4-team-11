---
title: "paper 1"
author: "Yuxin Zhu"
date: "2017/4/5"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(cluster)
library(plyr)
```

```{r}
# load data 
setwd("~/Documents/Columbia /2017 spring/ADS/proj 4")
load("profclean.RData")
```

```{r}
singlecluster <- function(df){

  n <- length(df)
  aa <- rep(0,n)
  # cluster.list <- 
  for (i in 1:(n-2)){
    bb <- rep(0,n)
    for (j in (i+1):n){
    # df[[i]][[3]] #coauthor names 
      bb[j]<- length(which(df[[i]][[3]]==df[[j]][[3]]))
    }
    aa[i] <- max(bb)
  
  }
  index.max <- max(aa)
  return(index.max)
}

singlecluster(df)
```


```{r}
n <- length(df)
csim <- matrix(rep(0,n*n),ncol=n)
c <- NULL
for (i in 1:n){
  c[[i]] <- df[[i]][[3]]
}

for (i in 1:n){
  for (j in 1:n){
   csim[i,j] <- length(which(df[[i]][[3]]==df[[j]][[3]]))
  }
}

```


```{r}
Lm <- as.data.frame(csim*(-1))
N <- nrow(Lm)
merge <- matrix(0, N-1, 2)
height <- vector(length = N-1)
diag(Lm) <- Inf
```


```{r}
colnames(Lm) <- -(1:N)
rownames(Lm) <- -(1:N)
```


```{r}
for (m in 1:(N-1)) { 
  cols <- colnames(Lm)
  
  # Johnson's algorithm Step 2L Find the pair with the most common coauthors
  
  # The which() function returns the row and column position of the pair
  d <- which(Lm == min(Lm), arr.ind = TRUE)[1,,drop=FALSE]
  if (min(Lm) <= (-1)){
    height[m] <- min(Lm) # The height is the value of the pair with the most common coauthors 
  
  # The row and column position of the most common pair is stored as sequence m in the merge object
  merge[m,] <- as.numeric(cols[d])
  
  # Johnson's algorithm Step 3: The pair with the minimum distance is merged
  
  # The cluster object is used to find previous clusters that the pair belong to (if they exist)
  # Does this by finding any columns above 0 (since all column names are negative, a positive 
  # column value implies it has been clustered)
  cluster <- c(d, which(cols %in% cols[d[1, cols[d] > 0]]))

  colnames(Lm)[cluster] <- m # Rename the columns indicated by cluster to the sequence number, m

  # Merge the pairs according to Johnson's algorithm and the single linkage method
  sl <- apply(Lm[d,], 2, min)
  
  # Johnson's algorithm Step 4: Remove column and row corresponding to old clusters and
  # insert a new column and row for newly formed cluster.
  
  # The insertion of the cluster is done by setting the first sequential row and column of the
  # minimum pair in the distance matrix (top to bottom, left to right) as the cluster resulting 
  # from the single linkage step
  Lm[min(d),] <- sl
  Lm[,min(d)] <- sl
  
  # Make sure the minimum distance pair is not used again by setting it to Inf
  Lm[min(d), min(d)] <- Inf
  
  # The removal step is done by setting the second sequential row and column of the minimum pair
  # (farthest right, farthest down) to Inf
  Lm[max(d),] <- Inf
  Lm[,max(d)] <- Inf
  }
}
```

```{r}
cluster.list <- matrix(0,ncol=n,nrow = n)
for (i in 1 : (N-1)){
  a <- merge[i,1]
  b <- merge[i,2]
  if (a<0 & b <0){
    cluster.list[i,1:2] <-c(-a,-b)
  }
  
}
```

```{r}
agn <- agnes(x=(csim*-1), diss = FALSE, stand = TRUE,method = "single")
DendAgn <-as.dendrogram(agn)
plot(DendAgn)
```

```{r}
n <- length(df)
merge <- matrix(0,n-1,2)
height <- vector(length=n-1)

```

```{r}
llply(data_list,singlecluster)
```