correlational<-(heatX==heatY)
selected<-input$selected
isReal<-grepl('real',selected)
isGrowth<-grepl('growth',selected)
isTimeSeries<-grepl('time',input$heatR)
if (!(selected %in% support_byYear)) {
output$title4<-renderText("Only support (real or nominal) GDP (.|growth)")
return(NULL)}
if (correlational & !isGrowth) {
output$title4<-renderText("Only support (real or nominal) GDP growth")
return(NULL)
}
# choose the right data to use
T1<-ifelse(isReal,'rGDP','nGDP')
T2<-ifelse(grepl('states',heatX),'_states','_regions')
T3<-ifelse(isGrowth,'_growth','')
T4<-'_byYear'
if (heatY=='sectors' & !correlational) {
varName <- paste0(T1,T2,T3,T4)
DF<-(get(varName)[[getYear()]])
}
else if (input$sector=='all' & !correlational) {
if (heatX=='states') DF <- getDataStates()
else { DF <- getDataRegions() }
} else if (input$sector!='all' & !correlational) {
if (heatX=='states' & grepl('real',selected)) {myList<-getSectorRGDPSectorDataStates()}
else if (heatX=='states' & !isReal) {myList<-getSectorNGDPSectorDataStates()}
else if (heatX=='regions' & isReal) {myList<-getSectorRGDPSectorDataRegions()}
else {myList<-getSectorNGDPSectorDataRegions()}
if (!isGrowth) {DF<-myList[['original']]}
else { DF<-myList[['growth']]}
}
if (correlational) {
if (isTimeSeries) {
if (heatX=='states'){
if (input$sector=='all') { DF<-getDataStates() }
else {if(isReal) {DF<-getSectorRGDPSectorDataStates()[['growth']]}
else {DF<-getSectorNGDPSectorDataStates()[['growth']]}
}
} else if (heatX == 'US regions') {
if (input$sector=='all') { DF<-getDataRegions()
} else  {
if (isReal) { DF<-getSectorRGDPSectorDataRegions()[['growth']] }
else { DF<-getSectorNGDPSectorDataRegions()[['growth']] }
DF<-filter(DF,!grepl('United States',GeoName)) }
} else if (heatX=='sectors') {
if (isReal) { X<-rGDP_sector_regions_growth}
else { X<- nGDP_sector_regions_growth }
for (key in names(X)) { X[[key]]<-filter(X[[key]],GeoName=='United States')}
DF<-StackDFs(X,'Sectors')
} else {return(NULL)}
} else {
# stub, not implemented yet for cross sessional correlations
if (heatX=='states'){
} else if (heatX=='regions') {
} else if (heatX=='sectors') {
}
}
if (!exists('DF')) {
return(NULL)}
myScale = 1.0
if (heatX=='states') {
rownames(DF)<-FindStateAbbreviation(DF[,1])
myScale = 0.7
}
else if (heatX =='US regions') {rownames(DF)<-FindRegionAbbreviation((DF[,1]))}
else if (heatX == 'sectors')  {rownames(DF)<-sectorsAbbreviations}
DF<-DF[,-1]
DF<-t(DF)
corMatrix<-cov2cor(var(DF,na.rm=T))
return(corrplot(corMatrix,method='circle',tl.cex=myScale,type='lower'))
}
DF<-TreatAsMissing(DF)
if (input$heatR=='relative') {
if (input$heatY=='sectors') DF<-NormalizeDFAlongRows(DF)
else DF<-NormalizeDFAlongColumns(DF)
}
DF<-melt(DF,id.var='GeoName')
if (heatY=='sectors') DF<-transmute(DF,GeoName=factor(GeoName),Sector=factor(variable),value)
else DF<-transmute(DF,GeoName=factor(GeoName),years=factor(variable),value)
if (heatX=='US regions') DF<-filter(DF,GeoName!='United States')
if (heatY=='sectors') g <- ggplot(DF, aes(x=GeoName, y=SectorAbbre(Sector),fill=value))
else g <- ggplot(DF,aes(x=GeoName,y=sub('X','',years),fill=value))
g<- g+ geom_tile() + scale_fill_gradientn(colors=c('black','dark red','red','orange','yellow','white'))
g<- g + xlab(switch(paste0(heatX,'W'),statesW='States',regionsW='US regions',sectorsW='Sectors'))
g<- g + ylab(switch(paste0(heatY,'W'),statesW='States',yearsW='Years',regionsW='US regions',sectorsW='Sectors'))
g<- g+ theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
return(g)
})
)
output$heat<-renderPlot({
if (values$starting) return(NULL)
Sys.sleep(0.6)
heatX<-input$heatX
if (heatX=='None') {
output$title4<-renderText("Heat Map X variable cannot be None!")
return(NULL)
} else if (heatX=='sectors' & input$heatY!='sectors') {return(NULL)}
heatY<-input$heatY
correlational<-(heatX==heatY)
selected<-input$selected
isReal<-grepl('real',selected)
isGrowth<-grepl('growth',selected)
isTimeSeries<-grepl('time',input$heatR)
if (!(selected %in% support_byYear)) {
output$title4<-renderText("Only support (real or nominal) GDP (.|growth)")
return(NULL)}
if (correlational & !isGrowth) {
output$title4<-renderText("Only support (real or nominal) GDP growth")
return(NULL)
}
# choose the right data to use
T1<-ifelse(isReal,'rGDP','nGDP')
T2<-ifelse(grepl('states',heatX),'_states','_regions')
T3<-ifelse(isGrowth,'_growth','')
T4<-'_byYear'
if (heatY=='sectors' & !correlational) {
varName <- paste0(T1,T2,T3,T4)
DF<-(get(varName)[[getYear()]])
}
else if (input$sector=='all' & !correlational) {
if (heatX=='states') DF <- getDataStates()
else { DF <- getDataRegions() }
} else if (input$sector!='all' & !correlational) {
if (heatX=='states' & grepl('real',selected)) {myList<-getSectorRGDPSectorDataStates()}
else if (heatX=='states' & !isReal) {myList<-getSectorNGDPSectorDataStates()}
else if (heatX=='regions' & isReal) {myList<-getSectorRGDPSectorDataRegions()}
else {myList<-getSectorNGDPSectorDataRegions()}
if (!isGrowth) {DF<-myList[['original']]}
else { DF<-myList[['growth']]}
}
if (correlational) {
if (isTimeSeries) {
if (heatX=='states'){
if (input$sector=='all') { DF<-getDataStates() }
else {if(isReal) {DF<-getSectorRGDPSectorDataStates()[['growth']]}
else {DF<-getSectorNGDPSectorDataStates()[['growth']]}
}
} else if (heatX == 'US regions') {
if (input$sector=='all') { DF<-getDataRegions()
} else  {
if (isReal) { DF<-getSectorRGDPSectorDataRegions()[['growth']] }
else { DF<-getSectorNGDPSectorDataRegions()[['growth']] }
DF<-filter(DF,!grepl('United States',GeoName)) }
} else if (heatX=='sectors') {
if (isReal) { X<-rGDP_sector_regions_growth}
else { X<- nGDP_sector_regions_growth }
for (key in names(X)) { X[[key]]<-filter(X[[key]],GeoName=='United States')}
DF<-StackDFs(X,'Sectors')
} else {return(NULL)}
} else {
# stub, not implemented yet for cross sessional correlations
if (heatX=='states'){
} else if (heatX=='regions') {
} else if (heatX=='sectors') {
}
}
if (!exists('DF')) {
return(NULL)}
myScale = 1.0
if (heatX=='states') {
rownames(DF)<-FindStateAbbreviation(DF[,1])
myScale = 0.7
}
else if (heatX =='US regions') {rownames(DF)<-FindRegionAbbreviation((DF[,1]))}
else if (heatX == 'sectors')  {rownames(DF)<-sectorsAbbreviations}
DF<-DF[,-1]
DF<-t(DF)
corMatrix<-cov2cor(var(DF,na.rm=T))
return(corrplot(corMatrix,method='circle',tl.cex=myScale,type='lower'))
}
DF<-TreatAsMissing(DF)
if (input$heatR=='relative') {
if (input$heatY=='sectors') DF<-NormalizeDFAlongRows(DF)
else DF<-NormalizeDFAlongColumns(DF)
}
DF<-melt(DF,id.var='GeoName')
if (heatY=='sectors') DF<-transmute(DF,GeoName=factor(GeoName),Sector=factor(variable),value)
else DF<-transmute(DF,GeoName=factor(GeoName),years=factor(variable),value)
if (heatX=='US regions') DF<-filter(DF,GeoName!='United States')
if (heatY=='sectors') g <- ggplot(DF, aes(x=GeoName, y=SectorAbbre(Sector),fill=value))
else g <- ggplot(DF,aes(x=GeoName,y=sub('X','',years),fill=value))
g<- g+ geom_tile() + scale_fill_gradientn(colors=c('black','dark red','red','orange','yellow','white'))
g<- g + xlab(switch(paste0(heatX,'W'),statesW='States',regionsW='US regions',sectorsW='Sectors'))
g<- g + ylab(switch(paste0(heatY,'W'),statesW='States',yearsW='Years',regionsW='US regions',sectorsW='Sectors'))
g<- g+ theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
return(g)
})
values<-reactiveValues(starting=T)
session$onFlushed(function() {  values$starting <- F})
# observe session
observe({
if (input$selected %in% noSectors)
updateSelectizeInput(session,'sector',selected='all')
})
observe({
Sys.sleep(0.1)
selected <- input$selected
updateSliderInput(session,'slider1',value=startYear[[selected]],min=startYear[[selected]],max=endYear[[selected]])
})
observe({
nonCorr<-input$heatX != input$heatY
Sys.sleep(0.1)
if (grepl('growth',input$selected) & nonCorr)
updateSelectizeInput(session,inputId='heatR',choices=c('absolute'))
else if (!grepl('growth',input$selected) & nonCorr) {updateSelectizeInput(session,inputId='heatR',choices=heatRelative)}
else {updateSelectizeInput(session,inputId='heatR',choices=c('time series'))}
})
observe({
Sys.sleep(0.1)
isInside <- input$heatY %in% c(heatYChoices,input$heatX)
if (input$heatX!='sectors' & isInside)
{ updateSelectizeInput(session,'heatY',choices=unique(c(heatYChoices,input$heatX)),selected=input$heatY) }
else if (input$heatX != 'sectors' & !isInside) {
updateSelectizeInput(session,'heatY',choices=unique(c(heatYChoices,input$heatX)))}
else { updateSelectizeInput(session,'heatY',choices=c('sectors')) }
})
observe({
Sys.sleep(0.1)
if (input$heatX==input$heatY)
updateSelectizeInput(session,'heatR',label=ts_cs,choices=c('time series'))#,'cross sectional'))
else if (!grepl('growth',input$selected)) {
originalOrElse<-ifelse(input$heatR%in%heatRelative,input$heatR,heatRelative[1])
updateSelectizeInput(session,'heatR',label=rela_abso,choices=heatRelative,selected=originalOrElse)}
})
observe({ updateSelectizeInput(session,'coordY',label='Y coordinate',setdiff(sectorsAbbreviations,input$coordX),selected='Finance') })
observe({ updateSelectizeInput(session,'stateB',label='second state',setdiff(states,input$stateA),selected='New York') })
observe({
Sys.sleep(0.1)
if (input$heatX==input$heatY)
{output$title4<-renderText(paste(input$heatX,'vs',input$heatY, "Correlation"))}
else if (!('years' %in% c(input$heatX,input$heatY)) & input$heatR!='time series')
{ output$title4<-renderText(paste0("Now it is year ",input$slider1)) }
else { output$title4<-renderText(paste(input$heatX,'vs Years 2D HEAT MAP'))}
})
library(shiny)
library(shinydashboard)
library(DT)
library(reshape2)
library(googleVis)
library(ggplot2)
if (!require(bubbles)) install.packages('bubbles')
library(bubbles)
if (!require(fields)) install.packages('fields')
library(fields)
if (!require(corrplot)) install.packages('corrplot')
library(corrplot)
library(dplyr)
suppressPackageStartupMessages(library(googleVis))
list.files()
runApp
output$heat<-renderPlot({
if (values$starting) return(NULL)
Sys.sleep(0.6)
heatX<-input$heatX
if (heatX=='None') {
output$title4<-renderText("Heat Map X variable cannot be None!")
return(NULL)
} else if (heatX=='sectors' & input$heatY!='sectors') {return(NULL)}
heatY<-input$heatY
correlational<-(heatX==heatY)
selected<-input$selected
isReal<-grepl('real',selected)
isGrowth<-grepl('growth',selected)
isTimeSeries<-grepl('time',input$heatR)
if (!(selected %in% support_byYear)) {
output$title4<-renderText("Only support (real or nominal) GDP (.|growth)")
return(NULL)}
if (correlational & !isGrowth) {
output$title4<-renderText("Only support (real or nominal) GDP growth")
return(NULL)
}
# choose the right data to use
T1<-ifelse(isReal,'rGDP','nGDP')
T2<-ifelse(grepl('states',heatX),'_states','_regions')
T3<-ifelse(isGrowth,'_growth','')
T4<-'_byYear'
if (heatY=='sectors' & !correlational) {
varName <- paste0(T1,T2,T3,T4)
DF<-(get(varName)[[getYear()]])
}
else if (input$sector=='all' & !correlational) {
if (heatX=='states') DF <- getDataStates()
else { DF <- getDataRegions() }
} else if (input$sector!='all' & !correlational) {
if (heatX=='states' & grepl('real',selected)) {myList<-getSectorRGDPSectorDataStates()}
else if (heatX=='states' & !isReal) {myList<-getSectorNGDPSectorDataStates()}
else if (heatX=='regions' & isReal) {myList<-getSectorRGDPSectorDataRegions()}
else {myList<-getSectorNGDPSectorDataRegions()}
if (!isGrowth) {DF<-myList[['original']]}
else { DF<-myList[['growth']]}
}
if (correlational) {
if (isTimeSeries) {
if (heatX=='states'){
if (input$sector=='all') { DF<-getDataStates() }
else {if(isReal) {DF<-getSectorRGDPSectorDataStates()[['growth']]}
else {DF<-getSectorNGDPSectorDataStates()[['growth']]}
}
} else if (heatX == 'US regions') {
if (input$sector=='all') { DF<-getDataRegions()
} else  {
if (isReal) { DF<-getSectorRGDPSectorDataRegions()[['growth']] }
else { DF<-getSectorNGDPSectorDataRegions()[['growth']] }
DF<-filter(DF,!grepl('United States',GeoName)) }
} else if (heatX=='sectors') {
if (isReal) { X<-rGDP_sector_regions_growth}
else { X<- nGDP_sector_regions_growth }
for (key in names(X)) { X[[key]]<-filter(X[[key]],GeoName=='United States')}
DF<-StackDFs(X,'Sectors')
} else {return(NULL)}
} else {
# stub, not implemented yet for cross sessional correlations
if (heatX=='states'){
} else if (heatX=='regions') {
} else if (heatX=='sectors') {
}
}
if (!exists('DF')) {
return(NULL)}
myScale = 1.0
if (heatX=='states') {
rownames(DF)<-FindStateAbbreviation(DF[,1])
myScale = 0.7
}
else if (heatX =='US regions') {rownames(DF)<-FindRegionAbbreviation((DF[,1]))}
else if (heatX == 'sectors')  {rownames(DF)<-sectorsAbbreviations}
DF<-DF[,-1]
DF<-t(DF)
corMatrix<-cov2cor(var(DF,na.rm=T))
return(corrplot(corMatrix,method='circle',tl.cex=myScale,type='lower'))
}
DF<-TreatAsMissing(DF)
if (input$heatR=='relative') {
if (input$heatY=='sectors') DF<-NormalizeDFAlongRows(DF)
else DF<-NormalizeDFAlongColumns(DF)
}
DF<-melt(DF,id.var='GeoName')
if (heatY=='sectors') DF<-transmute(DF,GeoName=factor(GeoName),Sector=factor(variable),value)
else DF<-transmute(DF,GeoName=factor(GeoName),years=factor(variable),value)
if (heatX=='US regions') DF<-filter(DF,GeoName!='United States')
if (heatY=='sectors') g <- ggplot(DF, aes(x=GeoName, y=SectorAbbre(Sector),fill=value))
else g <- ggplot(DF,aes(x=GeoName,y=sub('X','',years),fill=value))
g<- g+ geom_tile() + scale_fill_gradientn(colors=c('black','dark red','red','orange','yellow','white'))
g<- g + xlab(switch(paste0(heatX,'W'),statesW='States',regionsW='US regions',sectorsW='Sectors'))
g<- g + ylab(switch(paste0(heatY,'W'),statesW='States',yearsW='Years',regionsW='US regions',sectorsW='Sectors'))
g<- g+ theme(axis.text.x=element_text(angle = 90, vjust = 0.5))
return(g)
})
library(shiny)
library(shinydashboard)
library(DT)
library(reshape2)
library(googleVis)
library(ggplot2)
if (!require(bubbles)) install.packages('bubbles')
library(bubbles)
if (!require(fields)) install.packages('fields')
library(fields)
if (!require(corrplot)) install.packages('corrplot')
library(corrplot)
library(dplyr)
suppressPackageStartupMessages(library(googleVis))
# convert matrix to dataframe
load('./data.RData')
load('./sectorData.RData')
load('./sectorGrowthData.RData')
load('./byYear.RData')
data = list()
data$'personal income per capita' <- income.perCapita
data$'population' <- population
noRegions<-c('personal income per capita','population')
usRegions<-unique(GDP_regions[['per capita real GDP']]$GeoName)
usRegion2Abbr<-c('US','NE','ME','GL','PL','SE','SW','RM','FW')
names(usRegion2Abbr)<-usRegions
heatXChoices<-c('states','US regions','sectors')
heatYChoices<-c('years','sectors')
heatRelative<-c('absolute','relative')
support_byYear<-c("nominal GDP","real GDP","nominal GDP growth","real GDP growth")
rela_abso<-"Absolute or Relative:"
ts_cs<-"Correlation Type"
US_GDP_Visual<-'US GDP Data Visualization'
noSectors<-c("personal income per capita","population","per capita real GDP growth","per capita real GDP")
sectorsAbbreviations=c("Agriculture", "Mining", "Util", "Construt.",
"Manufac.", "Wholesale", "Retail", "Trans", "IT",
"Finance", "R estate", "Profess.", "Manage", "waste",
"Edu.", "Health care", "entertain.", "food & hotel",
"Other Xgov.", "Govern.")
names(sectorsAbbreviations) <- sectors
names(sectors) <- sectorsAbbreviations
SectorAbbre<-function(x) { return(sectorsAbbreviations[x]) }
SectorAbbre<-Vectorize(SectorAbbre)
choice <- c(c('personal income per capita','population'),names(GDP_states))
for (key in names(GDP_states)) {  data[[key]]<-GDP_states[[key]] }
states <- postCodes$US.State.
ConvertNum<-function(num) {
if (!is.numeric(num)) {return(num)}
if (abs(num)<=1) {return(paste0(floor(num*1000)/10,'%'))}
else if (abs(num)<1000 & abs(num)>1) {return(as.character(num))}
else if (abs(num) < 1e5) {
x = floor(num/1e2)/1e1
return(paste0(x,'K'))}
else if (abs(num) < 1e8) {
x = floor(num/1e4)/1e2
return(paste0(x,'M'))}
else if (abs(num) < 1e10) {
x = floor(num/1e7)/1e2
return(paste0(x,'B')) }
else {
x = floor(num/1e10)/1e2
return(paste0(x,'T')) }
}
ConvertNum<-Vectorize(ConvertNum)
FindStateAbbreviation<-function(name) {
z<-filter(postCodes, US.State.==name)
if (nrow(z)<1) {return(name)}
else {return(z$Abbreviation.)}
}
FindStateAbbreviation<-Vectorize(FindStateAbbreviation)
FindRegionAbbreviation<-function(name)  { usRegion2Abbr[[name]] }
FindRegionAbbreviation<-Vectorize(FindRegionAbbreviation)
NormalizeDFAlongRows<-function(DF) {
keys<-rownames(DF)
names<-names(DF)
is.numeric.col<-sapply(DF,is.numeric)
numericCols<-names[is.numeric.col]
DF2<-DF[,numericCols]
for (key in keys) DF2[key,]<-DF2[key,]/(sum(DF2[key,],na.rm=T)+1e-10)
DF[,numericCols]<-DF2[,numericCols]
return(DF)
}
NormalizeDFAlongColumns<-function(DF) {
names<-names(DF)
is.numeric.col<-sapply(DF,is.numeric)
for (x in names[is.numeric.col]) DF[[x]]<-DF[[x]]/(sum(DF[[x]],na.rm=T)+1e-10)
DF
}
TreatAsMissing<-function(DF,bound=1e16){
names<-names(DF)
is.numeric.col<-sapply(DF,is.numeric)
for (x in names[is.numeric.col]) {
bad <- abs(DF[[x]])>bound
DF[[x]][bad] <- NA
}
return(DF)
}
StackDFs<-function(myList,newColName) {
myNames<-names(myList)
DF<-as.data.frame(matrix(nrow=0,ncol=length(myNames)))
# a list of data frame of the same dim (1,n)
for (key in myNames) {
x <- myList[[key]]
DF<-rbind(DF,x)
}
DF[[1]]<-myNames
S      <-names(DF)
S[1]   <-newColName
return(DF)
}
library(shiny)
load("CrimeStatebyStateclean.csv")
state_crimes <- read.csv("CrimeStatebyState1.csv",header=T)
head(state_crimes)
heatXChoices <-c('states','US region')
heatYChoices <-c('years','criminal type')
sectorsAbbreviations=c("Murder", "Rape", "Robbery","Assault","Burglary","Larceny Theft","Motel Vehicle Theft")
names(sectorsAbbreviations) <- crime_type
names(crime_type) <- sectorsAbbreviations
load("states_crimes.rdata")
runApp('Documents/Columbia /2017 spring/ADS/crime_analysis_shiny_r')
runApp('Documents/Columbia /2017 spring/ADS/crime_analysis_shiny_r')
runApp('Documents/Columbia /2017 spring/ADS/crime_analysis_shiny_r')
runApp('Documents/Columbia /2017 spring/ADS/crime_analysis_shiny_r')
?opts
source("http://bioconductor.org/biocLite.R")
biocLite()
library("EBImage")
img <- readImage("chicken.jpg")
print(img)
source("http://bioconductor.org/biocLite.R")
biocLite()
library("EBImage")
img <- readImage("chicken.jpg")
print(img)
source("http://bioconductor.org/biocLite.R")
biocLite()
biocLite()
biocLite("EBImage")
library("EBImage")
img <- readImage("chicken.jpg")
img <- readImage("~/Documents/Columbia /2017 spring/ADS/project 3/training_data/raw_images/image_0001.jpg")
print(img)
load("zipcode.RData")
?prnom
?pnorm
pnorm(0.05)
pnorm(0.05)^-1
1/pnorm(0.05)
dnorm(1.923303)
qnorm(0.05)
dnorm(-1.644864)
dnorm(1.64)
?Sys.time
if (!require("pacman")) install.packages("pacman")
pacman::p_load(text2vec, dplyr, qlcMatrix, kernlab, knitr)
setwd("~/Spr2017-proj4-team-11/doc")
source("../lib/dataclean.R")
load("../data/data.RData")
if (!require("pacman")) install.packages("pacman")
pacman::p_load(text2vec, dplyr, qlcMatrix, kernlab, knitr)
setwd("~/Spr2017-proj4-team-11/doc")
source("../lib/dataclean.R")
